\usepackage{stmaryrd} 
\usepackage{proof}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{mathtools}
\usepackage{amsthm}
\usepackage{mathpartir}
\usepackage{color}
\usepackage{xstring}
\usepackage{ntabbing}
\usepackage{listings}
\usepackage{varwidth}
\usepackage{enumitem}


%Potential annotations
\newlength{\rWidth}

\newcommand{\funtype}[1]{%
    {\settowidth{\rWidth}{\ensuremath{#1}}%
        \;\ensuremath{{\xrightarrow{\hspace{\rWidth}}\hspace{-0.84\rWidth}}\!\!\!^%
         {#1}%{\BehindSubString{,}{#1} / \BeforeSubString{,}{#1}}%
         \hspace{0.2\rWidth}\;\;}}}


%% Notation
\newcommand{\m}[1]{\mathsf{#1}}
\newcommand{\mb}[1]{\mathbf{#1}}

\newenvironment{sill}{\begin{tabbing}}{\end{tabbing}}


%% Configuration
\newcommand{\conftree}[3]{\left[#1\right] \; \proc{#2}{#3}}
\newcommand{\confprovider}[2]{(#1)^{#2}}
\newcommand{\confset}[1]{\overline{#1}}
\newcommand{\esync}{\; \m{esync}}

%% Modes
\newcommand{\s}{\m{S}}
\renewcommand{\l}{\m{L}}
\renewcommand{\c}{\m{U}}
\newcommand{\p}{\m{P}}

\newcommand{\lang}[1]{\mathbf{L}(#1)}

%% Contexts and Typing Judgment
\newcommand{\W}{\Omega}
\newcommand{\Sg}{\Sigma}
\newcommand{\xvdash}[1]{%
  \vdash^{\mkern-8mu\scriptstyle\rule[-.9ex]{0pt}{0pt}#1}%
}
\newcommand{\xVdash}[1]{%
  \Vdash^{\mkern-8mu\scriptstyle\rule[-.9ex]{0pt}{0pt}#1}%
}
\newcommand{\confpot}[2]{\overset{#1}{\underset{#2}{\vDash}}}
\newcommand{\potconf}[1]{\overset{#1}{\vDash}}
\newcommand{\spanconf}{\vDash}
\newcommand{\confspan}[1]{\overset{(#1)}{\vDash}}
\newcommand{\confspanlocal}[1]{\overset{\langle #1 \rangle}{\vDash}}
\newcommand{\D}{\Delta}
\renewcommand{\G}{\Gamma}
\newcommand{\T}{\Theta}
\newcommand{\proves}{\vDash}
\newcommand{\w}{\omega}
\renewcommand{\C}{\mathcal{C}}
\newcommand{\set}[1]{\lvert\lvert#1\rvert\rvert}

\newcommand{\lin}[1]{\m{lin}(\overline{#1})}
\newcommand{\shd}[1]{\m{shd}(\overline{#1})}
\newcommand{\slin}[1]{\m{slin}(\overline{#1})}
\newcommand{\plin}{\; \m{purelin}}

%% Operational Semantics Predicates
\newcommand{\proc}[2]{\m{proc}(#1, #2)}
\newcommand{\msg}[2]{\m{msg}(#1, #2)}
\newcommand{\ichan}[3]{\m{ichan}(#1, #2, #3)}
\newcommand{\ochan}[3]{\m{ochan}(#1, #2, #3)}
\newcommand{\unavail}[1]{\m{unavail}(#1)}

%% Semantics
\newcommand{\step}{\mapsto}
\newcommand{\zerostep}{\step^{0}}
\newcommand{\mc}{\mathbf{c}}
\newcommand{\timed}[2]{\{#1\}_{#2}}
\newcommand{\unit}{M}
\newcommand{\Step}{\Longrightarrow}
\newcommand{\info}{\mapsto}
\newcommand{\andin}{\; \m{and} \;}
\newcommand{\minus}{\setminus}
\newcommand{\fresh}[1]{(#1 \text{ fresh})}
\newcommand{\eval}[1]{\Downarrow_{#1}}

%% Expressions Semantics
\newcommand{\val}{\; \m{val}}

%% Expressions
\newcommand{\lam}[3]{\lambda #1 : #2 . M_x}
\newcommand{\inl}[1]{l \cdot #1}
\newcommand{\inr}[1]{r \cdot #1}
\newcommand{\case}[3]{\m{case} \; #1 \; (l \hookrightarrow #2, r \hookrightarrow #3)}
\newcommand{\pair}[2]{\left\langle #1, #2 \right\rangle}
\newcommand{\projl}[1]{#1 \cdot l}
\newcommand{\projr}[1]{#1 \cdot r}
\newcommand{\match}[4]{\m{match} \; #1 \; ([] \rightarrow #2, #3 \rightarrow #4)}
\newcommand{\eproc}[3]{\{#1 \leftarrow #2 \leftarrow #3\}}


%% Proof Terms
\newcommand{\ecase}[3]{\m{case} \; #1 \; (#2 \Rightarrow #3)}
\newcommand{\ecasecf}[3]{\m{case^{cf}} \; #1 \; (#2 \Rightarrow #3)}
\newcommand{\erecvch}[2]{#2 \leftarrow \m{recv} \; #1}
\newcommand{\erecvchcf}[2]{#2 \leftarrow \m{recv^{cf}} \; #1}
\newcommand{\erecvshift}[1]{\m{shift} \leftarrow \m{recv} \; #1}
\newcommand{\esendch}[2]{\m{send} \; #1 \; #2}
\newcommand{\esendchcf}[2]{\m{send^{cf}} \; #1 \; #2}
\newcommand{\esendshift}[1]{\m{send} \; #1 \; \m{shift}}
\newcommand{\ewait}[1]{\m{wait} \; #1}
\newcommand{\ewaitcf}[1]{\m{wait^{cf}} \; #1}
\newcommand{\eclose}[1]{\m{close} \; #1}
\newcommand{\eclosecf}[1]{\m{close^{cf}} \; #1}
\newcommand{\fwd}[2]{#1 \leftarrow #2}
\newcommand{\fwdp}[2]{#1 \overset{+}{\leftarrow} #2}
\newcommand{\fwdn}[2]{#1 \overset{-}{\leftarrow} #2}
\newcommand{\esendl}[2]{#1.#2}
\newcommand{\esendlcf}[2]{(#1.#2)^{\m{cf}}}
\newcommand{\ecut}[4]{#1 \leftarrow #2 \leftarrow #3 \semi #4}
\newcommand{\espawn}[4]{#1 \leftarrow #2 \leftarrow #3 = #4}
\newcommand{\procg}[3]{\m{proc}(#1, #2, \overline{#3})}
\newcommand{\edelay}[1]{\m{delay} \; (#1)}
\newcommand{\ewhen}[2]{\m{when?} \; (#1) ; #2}
\newcommand{\enow}[2]{\m{now!} \; (#1) ; #2}
\newcommand{\etick}[1]{\m{tick} \; (#1)}
\newcommand{\ework}[1]{\m{work} \; \{#1\}}
\newcommand{\eget}[2]{\m{get} \; #1 \; \{#2\}}
\newcommand{\epay}[2]{\m{pay} \; #1 \; \{#2\}}
\newcommand{\procdef}[3]{#3 \leftarrow #1 \leftarrow #2}
\newcommand{\procdefna}[2]{#2 \leftarrow #1}
\newcommand{\casedef}[1]{\m{case} \; #1}
\newcommand{\labdef}[1]{#1 \Rightarrow}
\newcommand{\wk}[1]{\m{work}(#1)}
\newcommand{\eif}[1]{\m{if} \; (#1)}
\newcommand{\ethen}{\; \m{then} \; }
\newcommand{\eelse}{\m{else} \; }
\newcommand{\eassume}[2]{\m{assume} \; #1 \; \{#2\}}
\newcommand{\eassert}[2]{\m{assert} \; #1 \; \{#2\}}
\newcommand{\eimpos}[2]{\m{impossible} \; #1 \; \{#2\}}

%% Type Constructors
\newcommand{\lolli}{\multimap}
\newcommand{\tensor}{\otimes}
\newcommand{\with}{\mathbin{\binampersand}}
\newcommand{\paar}{\mathbin{\bindnasrepma}}
\newcommand{\one}{\mathbf{1}}
\newcommand{\zero}{\mathbf{0}}
\newcommand{\bang}{{!}}
\newcommand{\whynot}{{?}}
\newcommand{\semi}{\; ; \;}
\newcommand{\ichoiceop}{\oplus}
\newcommand{\echoiceop}{\with}
\newcommand{\ichoice}[1]{\ichoiceop \{ #1 \}}
\newcommand{\echoice}[1]{\echoiceop \{ #1 \}}
\newcommand{\fuse}{\bullet}
\newcommand{\mi}[1]{\mbox{\it #1}}
\newcommand{\lunder}{\mathbin{\backslash}}
\newcommand{\arrow}{\to}
\newcommand{\product}{\times}
\newcommand{\tassertop}{?}
\newcommand{\tassumeop}{!}
\newcommand{\tassert}[1]{\; \tassertop\{#1\}. \;}
\newcommand{\tassume}[1]{\; \tassumeop\{#1\}. \;}


%% Functional Types
\newcommand{\tproc}[2]{\{#1 \leftarrow #2\}}

%% Types with Potential
\newcommand{\pot}[2]{#1^{#2}}
\newcommand{\lollipot}[1]{\overset{#1}{\lolli}}
\newcommand{\tensorpot}[1]{\overset{#1}{\tensor}}
\newcommand{\potfop}{\phi}
\newcommand{\potf}[1]{\potfop(#1)}
\newcommand{\mlab}{M^{\textsf{label}}}
\newcommand{\mchan}{M^{\textsf{channel}}}
\newcommand{\mcl}{M^{\textsf{close}}}
\newcommand{\mall}{M}
\newcommand{\mint}{M^{\textsf{internal}}}
\newcommand{\mval}{M^{\textsf{value}}}
\newcommand{\mshd}{M^{\textsf{share}}}
\newcommand{\ms}{M_s}
\newcommand{\mr}{M_r}
\newcommand{\entailpot}[1]{\xvdash{#1}}
\newcommand{\exppot}[1]{\xVdash{#1}}
\newcommand{\paypot}{\triangleright}
\newcommand{\getpot}{\triangleleft}
\newcommand{\tgetpot}[2]{\getpot^{#2} #1}
\newcommand{\tpaypot}[2]{\paypot^{#2} #1}
\newcommand{\bigeval}[3]{#1 \Downarrow #2 \mid #3}
\newcommand{\share}{\curlyveedownarrow}


%% Temporal Types
\newcommand{\entailpotcf}[1]{\underset{\m{cf}}{\entailpot{#1}}}
\newcommand{\entailspan}{\vdash}
\newcommand{\entailtype}{\vdash}
\newcommand{\fpot}{\; @ \;}
\newcommand{\pay}[1]{#1^{1}}
\newcommand{\sync}[1]{#1^{2}}
\newcommand{\spanpot}[1]{\langle \pay{#1}, \sync{#1} \rangle}
\newcommand{\ichoicepot}[2]{\overset{#1}{\ichoiceop} \{ #2 \}}
\newcommand{\echoicepot}[2]{\overset{#1}{\echoiceop} \{ #2 \}}
\newcommand{\tlist}[1]{\m{list}_{#1}}
\newcommand{\plist}[2]{L^{#2}(#1)}
\newcommand{\tdia}[1]{\Diamond #1}
\newcommand{\tbox}[1]{\Box #1}
\newcommand{\tforall}[1]{\forall . #1}
\newcommand{\texists}[1]{\exists . #1}
\newcommand{\delay}[2]{\left[#1\right]_{#2}}
\newcommand{\Next}{\raisebox{0.3ex}{$\scriptstyle\bigcirc$}}
\renewcommand{\next}[1]{\Next #1}
\newcommand{\tdelay}[2]{
    \IfEqCase{#2}{%
        {1}{\next{#1}}%
        % you can add more cases here as desired
    }[{\Next^{#2} (#1)}]%
}%
\newcommand{\tock}[1]{`#1}
\newcommand{\sch}[1]{\tau(#1)}
\newcommand{\lforce}[2]{[#1]_L^{#2}}
\newcommand{\rforce}[2]{[#1]_R^{#2}}
\newcommand{\force}[2]{#1 \circ (#2)}


%% Indices
\newcommand{\indv}[1]{\overline{\{#1\}}}
\newcommand{\ind}[1]{\{#1\}}


%% Syntactic Sugar
\newcommand{\config}{\mathcal{C}}
\newcommand{\cost}[2]{\mathrm{cost}(\proc{#1}{#2})}
\newcommand{\tcost}[2]{\mathrm{cost}(#1 \mapsto #2)}
\newcommand{\ccost}[1]{\mathrm{cost}(#1)}
\newcommand{\dc}{\mathcal{D}}
\newcommand{\ec}{\mathcal{E}}
\newcommand{\ac}{\mathcal{A}}
\newcommand{\st}[1]{\m{store}_{#1}}
\newcommand{\stack}[1]{\m{stack}_{#1}}
\newcommand{\queue}[1]{\m{queue}_{#1}}
\newcommand{\mapper}[1]{\m{mapper}_{#1}}
\newcommand{\fdr}[1]{\m{folder}_{#1}}
\newcommand{\lt}[1]{\m{list}_{#1}}
\newcommand{\bits}{\m{bits}}
\newcommand{\ctr}{\m{ctr}}
\newcommand{\trans}[2]{#1 \Longrightarrow #2}
\newcommand{\typetrans}[1]{\left\lvert{#1}\right\rvert}
\newcommand{\tree}{\m{tree}}
\newcommand{\bool}{\m{bool}}
\newcommand{\delayedbox}[1]{#1 \; \m{delayed}^{\Box}}
\newcommand{\delayeddia}[1]{#1 \; \m{delayed}^{\Diamond}}
\newcommand{\dom}[1]{\m{dom}(#1)}
\newcommand{\valid}[1]{#1 \; \m{valid}}

%% Smart Contracts
\newcommand{\addr}{\m{addr}}
\newcommand{\ether}{\m{ether}}
\newcommand{\players}{\m{players}}
\newcommand{\lottery}{\m{lottery}}
\newcommand{\tint}{\m{int}}
\newcommand{\ballot}{\m{ballot}}
\newcommand{\tbool}{\m{bool}}
\newcommand{\lc}{\tlist{\m{coin}}}
\newcommand{\auction}{\m{auction}}
\newcommand{\object}{\m{object}}
\newcommand{\plcoin}{\m{plcoin}}
\newcommand{\plcoins}{\m{plcoins}}
\newcommand{\plcoinsn}{pl coins}

%% Typing Judgments for Servers and Clients
\newcommand{\sentailpot}[1]{\prescript{}{S}{\xvdash{#1}} \hspace{2pt}}
\newcommand{\centailpot}[1]{\prescript{}{C}{\xvdash{#1}} \hspace{2pt}}


%% Sharing
\newcommand{\down}{\downarrow^{\m{S}}_{\m{L}}}
\newcommand{\up}{\uparrow^{\m{S}}_{\m{L}}}
\newcommand{\eacquire}[2]{#1 \leftarrow \m{acquire} \; #2}
\newcommand{\eaccept}[2]{#1 \leftarrow \m{accept} \; #2}
\newcommand{\erelease}[2]{#1 \leftarrow \m{release} \; #2}
\newcommand{\edetach}[2]{#1 \leftarrow \m{detach} \; #2}


%% Subtyping
\newcommand{\subt}[2]{#1 \leq #2}
\newcommand{\wsubt}{ <: }
\newcommand{\qsubt}[1]{\overset{#1}{\leq}}


%% Latex
\newtheorem{theorem}{Theorem}
\newtheorem{definition}{Definition}
\newtheorem{lemma}{Lemma}
\newtheorem{cor}{Corollary}


%%Global Semantics
\newcommand{\sinfer}[3]
{\inferrule
{#3}
{#2}
#1}
\newcommand{\enq}[2]{\m{enq}(#1, #2)}
\newcommand{\deq}[1]{\m{deq}(#1)}
\newcommand{\nil}{[]}
\newcommand{\elem}[1]{[#1]}


%% Channel typing
\newcommand{\eqdef}{\cong}


%% Types to Processes
\newcommand{\typeProc}[2]{#1 \Longrightarrow #2}

%% Solidity
\definecolor{verylightgray}{rgb}{.97,.97,.97}

\lstdefinelanguage{Solidity}{
	keywords=[1]{anonymous, assembly, assert, balance, break, call, callcode, case, catch, class, constant, continue, constructor, contract, debugger, default, delegatecall, delete, do, else, emit, event, experimental, export, external, false, finally, for, function, gas, if, implements, import, in, indexed, instanceof, interface, internal, is, length, library, log0, log1, log2, log3, log4, memory, modifier, new, payable, pragma, private, protected, public, pure, push, require, return, returns, revert, selfdestruct, send, solidity, storage, struct, suicide, super, switch, then, this, throw, transfer, true, try, typeof, using, value, view, while, with, addmod, ecrecover, keccak256, mulmod, ripemd160, sha256, sha3}, % generic keywords including crypto operations
	keywordstyle=[1]\color{blue}\bfseries,
	keywords=[2]{address, bool, byte, bytes, bytes1, bytes2, bytes3, bytes4, bytes5, bytes6, bytes7, bytes8, bytes9, bytes10, bytes11, bytes12, bytes13, bytes14, bytes15, bytes16, bytes17, bytes18, bytes19, bytes20, bytes21, bytes22, bytes23, bytes24, bytes25, bytes26, bytes27, bytes28, bytes29, bytes30, bytes31, bytes32, enum, int, int8, int16, int24, int32, int40, int48, int56, int64, int72, int80, int88, int96, int104, int112, int120, int128, int136, int144, int152, int160, int168, int176, int184, int192, int200, int208, int216, int224, int232, int240, int248, int256, mapping, string, uint, uint8, uint16, uint24, uint32, uint40, uint48, uint56, uint64, uint72, uint80, uint88, uint96, uint104, uint112, uint120, uint128, uint136, uint144, uint152, uint160, uint168, uint176, uint184, uint192, uint200, uint208, uint216, uint224, uint232, uint240, uint248, uint256, var, void, ether, finney, szabo, wei, days, hours, minutes, seconds, weeks, years},	% types; money and time units
	keywordstyle=[2]\color{teal}\bfseries,
	keywords=[3]{block, blockhash, coinbase, difficulty, gaslimit, number, timestamp, msg, data, gas, sender, sig, value, now, tx, gasprice, origin},	% environment variables
	keywordstyle=[3]\color{violet}\bfseries,
	identifierstyle=\color{black},
	sensitive=false,
	comment=[l]{//},
	morecomment=[s]{/*}{*/},
	commentstyle=\color{gray}\ttfamily,
	stringstyle=\color{red}\ttfamily,
	morestring=[b]',
	morestring=[b]"
}