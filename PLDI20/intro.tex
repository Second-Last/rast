\section{Introduction}
Statically expressing and verifying the specifications of
programs is an important problem which has received significant
attention in the past (cite standard verification papers).
However, most of the tools and techniques
addressing this challenge have been designed for sequential
systems (cite standard analyses of sequential programs papers).
This is in sharp contrast with the need for programming
language support for distributed and concurrent systems which
are increasingly pervasive and particularly difficult to analyze
(cite some papers which analyze concurrent systems).
For instance, the interactive nature of messsage-passing systems
makes it difficult to decompose the system into individual parts
that can be analyzed in isolation. Distributed systems also suffer
from deadlocks and read-write overheads due to shared memory
further complicating the verification of their intended purpose.

\emph{Session types} (cite Honda's papers on session types) provide
a structured way of
prescribing communication protocols of message-passing systems.
This article focuses on \emph{binary session types} (cite Frank's
session types papers) that type
a channel connecting two processes, thereby governing their interaction.
Session types exist in a Curry-Howard isomorphism with linear logic
(cite Frank's CH isomorphism paper)
and provide a compositional description of a process' communication
protocol. Moreover, the type safety of session types guarantees
\emph{progress} or deadlock freedom, and preservation or
\emph{session fidelity} ensuring that at runtime, the sender and
receiver exchange messages prescribed by their type.

However, simple session types have limited expressivity. As a
simple example, consider the session type offered by a queue
data structure storing elements of type $A$.
\begin{sill}
$\queue{A} = \echoice{$\=$\mb{ins} : A \lolli \queue{A},$\\
\>$\mb{del} : \ichoice{$\=$\mb{none} : \one,$\\
\>\>$\mb{some} : A \tensor \queue{A}}}$
\end{sill}
This type describes the queue interface supporting insertion and
deletion. The \emph{external choice} operator $\echoiceop$ dictates
that the data structure can either accept $\mb{ins}$ or $\mb{del}$
labels. In the case of $\mb{ins}$, it receives an element of type
$A$ denoted by the $\lolli$ operator, and then the type recurses
back to $\queue{A}$. On receiving a $\mb{del}$ request, the data
structure either returns $\mb{none}$ and \emph{terminates} (indicated
by $\one$) if the queue is empty, or returns $\m{some}$ followed
by the element using the $\tensor$ operator and recurses.
However, the simple session type cannot express the size of the
queue, thus cannot determine when to take the $\mb{none}$ or
$\mb{some}$ branch.

We propose extending session types with simple arithmetic
refinements to express, for instance, the size of the queue.
The new type
\begin{sill}
$\queue{A}[n] = \echoice{$\=$\mb{ins} : A \lolli \queue{A}[n+1],$\\
\>$\mb{del} : \ichoice{$\=$\mb{none} : \tassert{n=0} \one,$\\
\>\>\hspace{-1.5em}$\mb{some} : \tassert{n > 0} A \tensor \queue{A}[n-1]}}$
\end{sill}
uses the index refinement $n$ to indicate the size of the queue.
The type increments the index in the case of $\mb{ins}$,
while decrements it in the case of $\mb{del}$. Moreover, the
new type constructor $\tassert{\cdot}$ indicates that the $\mb{none}$
branch is taken when $n = 0$, and the $\mb{some}$ branch is taken
when $n > 0$. Theoretically, it requires the provider of $\tassert{\phi} A$
to send a proof of $\phi$, which is received by its client.

Simple arithmetic refinements are instrumental in expressing
\emph{sequential} and \emph{parallel complexity bounds}. Prior work
on resource-aware (cite rast and Nomos) and temporal session types
(cite temporal) rely on such index refinements to express the size of
lists, stacks and queue data structures, or the height of trees and
express work and time bounds as a function of these indices.
However, they do not discuss the metatheory for these arithmetic
refinements.

This article explores the metatheory of session types refined with
expressions from the Presburger arithmetic layer with a specific
focus towards the \emph{implementation challenges}. Moreover, the
type system is \emph{structural} enabling programmers to reuse
labels and \emph{equi-recursive} and does not require explicit fold
or unfold messages. This is coherent with the concurrent nature of
session types where two types should be considered equal if they have
the same communication behavior. We show that type checking for this
system is undecidable establishing a reduction from the non-halting
problem to type equality.

To make the system feasible, we propose a novel type equality algorithm
and prove its soundness. This algorithm works very well in practice and
produced the expected result on over 300 examples that we experimented with.
We claim that this algorithm is more general than session type systems
and can be applied towards other structural and equi-recursive languages.

We have implemented this language in SML. We have also extended this implementation
to resource-aware and temporal session types so that programmers can express
work and time bounds that are automatically verified by the type checker.
The implementation consists of a lexer, parser, type checker and execution
engine enabling programmers to compile and run their session-typed programs.
To the best of our knowledge, this is the first implementation of resource-aware
and temporal session types.

Our implementation also automatically performs work and time reconstruction.
Resource-aware and temporal session types also extend the expression language
with work and time constructs such as $\m{work}, \m{pay}$ and $\m{get}$ to exchange
and consume potential and $\m{delay}, \m{when?}$ and $\m{now!}$ to advance time.
However, these constructs are tedious to write for the programmer. Our type checker
automatically infers and inserts these constructs in the program. Thus, the
programmer can implement the programs without worrying about these constructs.
Finally, we provide limited support for inference, where the exact values of
work and time annotations in the type can be automatically computed using
a naive SMT solver.

To summarize, we make the following contributions:
\begin{enumerate}
  \item Design and implementation of a session-typed language with arithmetic
  refinements
  \item Proof of undecidability of the type system
  \item A novel type equality algorithm that works well in practice
  \item Extension to resource-aware and temporal session types allowing
  programmers to verify work and time bounds
  \item Automatic work and time reconstruction, and limited form of inference
\end{enumerate}