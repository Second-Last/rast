#test success

%%% from Henry, email of June 19, 2020

type Stack[A][alpha] = &{ push : A -o Stack[A][Some[A][alpha]],
                          pop : alpha }
type Some[A][alpha] = +{ some : A * Stack[A][alpha] }
type None           = +{ none : 1 }

type Either[A]      = +{ none : 1, some : A * Stack[A][Either[A]] }

%%% Stacks as chains

decl emp[A] : . |- (s : Stack[A][None])
proc s <- emp[A] =
  case s ( push => x <- recv s ;
                   s' <- emp[A] ;
                   s <- elem[A][+{none : 1}] x s'
         | pop => s.none ; close s )

decl elem[A][alpha] : (x : A) (t : Stack[A][alpha]) |- (s : Stack[A][Some[A][alpha]])
proc s <- elem[A][alpha] x t =
  case s ( push => y <- recv s ;
                   s' <- elem[A][alpha] x t ;
                   s <- elem[A][Some[A][alpha]] y s'
         | pop => s.some ; send s x ; s <-> t )

%%% Reversing "imprecise" stacks
%%% hypothesizing a subtyping coercion

decl rev[A] : (a : Stack[A][Either[A]]) (t : Stack[A][Either[A]]) |- (s : Stack[A][Either[A]])
proc s <- rev[A] a t =
  t.pop ;
  case t ( none => wait t ; s <-> a
         | some => x <- recv t ;            % t : Stack[A][Either[A]]
                   a.push ; send a x ;      % a : Stack[A][Some[A][Either[A]]]
                   a' <- stackSomeEither[A] a ;  % a' : Stack[A][Either[A]]
                   s <- rev[A] a' t )

%%% Subtype coercions

% Some[A][Either[A]] <: Either[A]
% None               <: Either[A]
decl someEither[A] : (a : Some[A][Either[A]]) |- (s : Either[A])
decl noneEither[A] : (a : None)               |- (s : Either[A])

proc s <- someEither[A] a =
  case a ( some => x <- recv a ;        % a : Stack[A][Either[A]]
                   s.some ; send s x ;  % s : Stack[A][Either[A]]
                   s <-> a )
proc s <- noneEither[A] a =
  case a ( none =>                      % a : 1
                   s.none ;             % s : 1
                   s <-> a )

%%% Subtype coercions fail for stacks?
%%% Stack[A][Some[A][Either[A]]] <: Stack[A][Either[A]] ?
%%% Stack[A][None]               <: Stack[A][Either[A]] ?
decl stackSomeEither[A] : (a : Stack[A][Some[A][Either[A]]]) |- (s : Stack[A][Either[A]])
decl stackNoneEither[A] : (a : Stack[A][None])               |- (s : Stack[A][Either[A]])

(*
proc s <- stackSomeEither[A] a =
  case s ( push => x <- recv s ;         % s : Stack[A][Some[A][Either[A]]]
                   a.push ; send a x ;   % a : Stack[A][Some[A][Some[A][Either[A]]]]
                   s <- stackSomeEither[A] a  % ill-typed!!!
         | pop =>                                      % s : Either[A]
                  a.pop ;                              % a : Some[A][Either[A]]
                  case a ( some => x <- recv a ;       % a : Stack[A][Either[A]]
                                   s.some ; send s x ; % s : Stack[A][Either[A]]
                                   s <-> a ) )
*)

(*
proc s <- stackNoneEither[A] a =
  case s ( push => x <- recv s ;         % s : Stack[A][Some[A][Either[A]]]
                   a.push ; send a x ;   % a : Stack[A][Some[A][None]]
                   s <- stackNoneEither[A] a  % ill-typed!!!
         | pop => a.pop ;                % a : None
                  case a ( none =>       % a : 1
                                   s.none ;
                                   s <-> a ) )
*)

% Trying it out

type nat = +{ z : 1, s : nat }

decl zero : . |- (n : nat)
decl one : . |- (n : nat)
decl two : . |- (n : nat)

proc n <- zero = n.z ; close n
proc n <- one = n.s ; n.z ; close n
proc n <- two = n.s ; n.s ; n.z ; close n

decl s123 : . |- (s : Stack[nat][Some[nat][Some[nat][Some[nat][None]]]])
proc s <- s123 =
  t <- emp[nat] ;
  n0 <- zero ;
  t.push ; send t n0 ;
  n1 <- one ;
  t.push ; send t n1 ;
  n2 <- two ;
  t.push ; send t n2 ;
  s <-> t

decl w123 : . |- (s : Stack[nat][Either[nat]])
proc s <- w123 =
  t <- emp[nat] ;
  t <- stackNoneEither[nat] t ;
  n0 <- zero ;
  t.push ; send t n0 ;
  t <- stackSomeEither[nat] t ;
  n1 <- one ;
  t.push ; send t n1 ;
  t <- stackSomeEither[nat] t ;
  n2 <- two ;
  t.push ; send t n2 ;
  t <- stackSomeEither[nat] t ;
  s <-> t

decl w321 : . |- (s : Stack[nat][Either[nat]])
proc s <- w321 =
  t <- w123 ;
  e <- emp[nat] ;
  e' <- stackNoneEither[nat] e ;
  s <- rev[nat] e' t

exec s123
% exec w123
% exec w321
